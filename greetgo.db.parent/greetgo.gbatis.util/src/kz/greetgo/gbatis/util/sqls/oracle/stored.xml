<?xml version="1.0" encoding="UTF-8" ?>
<sql-set>

  <sql id="executeCommandList_procedures" type="Sele"><![CDATA[
    create or replace function q_getInt(binData bytea, pos int) returns int
    language 'plpgsql' as $quote$
    
      begin
        
        return (get_byte(binData, pos + 0)      )
             | (get_byte(binData, pos + 1) <<  8)
             | (get_byte(binData, pos + 2) << 16)
             | (get_byte(binData, pos + 3) << 24)
        ;
        
      end
    
    $quote$
    
    ;;
    
    create or replace function q_getLong(binData bytea, pos int) returns bigint
    language 'plpgsql' as $quote$
    
      begin
        
        return (get_byte(binData, pos + 0)::bigint      )
             | (get_byte(binData, pos + 1)::bigint <<  8)
             | (get_byte(binData, pos + 2)::bigint << 16)
             | (get_byte(binData, pos + 3)::bigint << 24)
             | (get_byte(binData, pos + 4)::bigint << 32)
             | (get_byte(binData, pos + 5)::bigint << 40)
             | (get_byte(binData, pos + 6)::bigint << 48)
             | (get_byte(binData, pos + 7)::bigint << 56)
        ;
        
      end
    
    $quote$
    
    ;;
    
    create or replace function q_readInt(in binData bytea, inout pos int, out res int)
    language 'plpgsql' as $quote$
    
    begin
      res := q_getInt(binData, pos);
      pos := pos + 4;
    end
    
    $quote$
    
    ;;
    
    create or replace function q_getStr(binData bytea, pos int, len int) returns text
    language 'plpgsql' as $quote$
    
    declare
      partData bytea;
    begin
      if len = 1 and get_byte(binData, pos) = 0 then
        return null;
      end if;
      
      partData := substring(binData from pos + 1 for len);
      
      return convert_from(partData, 'UTF8');
      
    end
    
    $quote$
    
    ;;
    
    create or replace function q_getTime(binData bytea, pos int, len int) returns timestamp without time zone
    language 'plpgsql' as $quote$
    
    declare
      partData bytea;
      str_value text;
    begin
      if len = 1 and get_byte(binData, pos) = 0 then
        return null;
      end if;
      
      partData := substring(binData from pos + 1 for len);
      
      str_value := convert_from(partData, 'UTF8');
      
      return to_timestamp(str_value, 'yyyy-mm-dd hh24:mi:ss.ms')::timestamp without time zone;
      
    end
    
    $quote$
    
    ;;
    
    create or replace function q_readStr(in binData bytea, inout pos int, out res text)
    language 'plpgsql' as $quote$
    
    declare
      len int;
    begin
      
      select * from q_readInt(binData, pos) into pos, len;
      
      res := q_getStr(binData, pos, len);
      
      pos := pos + len;
      
    end
    
    $quote$
    
    ;;
    
    create or replace function q_executeCommandList(commands text) returns void
    language 'plpgsql' as $quote$
    
    declare
      binCommands bytea;
      pos int;
      
      command text;
      procedureName text;
      argumentCount int;
      
      needComma boolean;
      
      exec_str text;
      argumentTypeId int;
      valueLen int;
    begin
      
      pos := 0;
      binCommands := decode(commands, 'base64');
      
      --insert into temp_storage (txt) values ('Hello from q_executeCommandList: commands = '||commands);
      --insert into temp_storage (txt) values ('octet_length(binCommands) = '||octet_length(binCommands));
      
      <<main_loop>>
      loop
        
        select * from q_readStr(binCommands, pos) into pos, command;
        
        --insert into temp_storage (txt) values ('command = '||command);
        
        if command = 'exit' then
          exit main_loop;
        end if;
      
        if command = 'callProcedure' then
          
          select * from q_readStr(binCommands, pos) into pos, procedureName;
          select * from q_readInt(binCommands, pos) into pos, argumentCount;
          
          --insert into temp_storage (txt) values ('procedureName = '||procedureName);
          --insert into temp_storage (txt) values ('argumentCount = '||argumentCount);
          
          exec_str := 'select '||procedureName||'(';
          needComma := false;
          
          <<argument_loop>>
          while argumentCount > 0 loop
            argumentCount := argumentCount - 1;
            
            argumentTypeId := get_byte(binCommands, pos);
            pos := pos + 1;
            
            if argumentTypeId = 1 then -- -- -- CODE 1 ===> text
              
              select * from q_readInt(binCommands, pos) into pos, valueLen;
              
              if needComma then exec_str := exec_str || ', '; else needComma := true; end if;
              exec_str := exec_str || 'q_getStr($1, ' || pos || ', ' || valueLen || ')';
              
              pos := pos + valueLen;
              
              continue argument_loop;
            end if;
            
            if argumentTypeId = 2 then -- -- -- CODE 2 ===> int
              
              if needComma then exec_str := exec_str || ', '; else needComma := true; end if;
              exec_str := exec_str || 'q_getInt($1, ' || pos || ')';
              
              pos := pos + 4;
              
              continue argument_loop;
            end if;
            
            if argumentTypeId = 3 then -- -- -- CODE 3 ===> long
              
              if needComma then exec_str := exec_str || ', '; else needComma := true; end if;
              exec_str := exec_str || 'q_getLong($1, ' || pos || ')';
              
              pos := pos + 8;
              
              continue argument_loop;
            end if;
            
            if argumentTypeId = 4 then -- -- -- CODE 4 ===> time
              
              select * from q_readInt(binCommands, pos) into pos, valueLen;
              
              if needComma then exec_str := exec_str || ', '; else needComma := true; end if;
              exec_str := exec_str || 'q_getTime($1, ' || pos || ', ' || valueLen || ')';
              
              pos := pos + valueLen;
              
              continue argument_loop;
            end if;
            
            raise exception 'Unknown argumentTypeId = %', argumentTypeId;
            
          end loop;
          
          exec_str := exec_str || ')';
          
          --insert into temp_storage (txt) values ('exec_str = '||exec_str);
          execute exec_str using binCommands;
          
          continue main_loop;
          
        end if;
      
      end loop;
      
    end
    
    $quote$
  ]]></sql>

</sql-set>