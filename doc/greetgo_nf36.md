
## greetgo.nf36

### Общее описание

greetgo.nf36 предоставляет возможность синхронной работы с 3-ей и 6-ой нормальными формами в БД за счёт кодогенерации.

3-я нормальная форма используется для работы с оперативными данными.

В 6-ой нормальной форме сохраняется вся история изменений - кто и когда менял тот или иной параметр
(автор изменений и время изменений).

6-я нормальная форма обновляется синхронно с 3-ей нормальной формой в транзакционном режиме автоматически.

Вы просто говорите системе: вот в таком субъекте (с таким идентификатором) изменились такие и такие поля
на такие и такие значения - система меняет значения в 3-ей нормальной форме и добавляет строки в 6-ю нормальную фому,
при этом автоматически записывает время изменений и авторма изменений: автор берётся автоматически из сессии.

Например, у нас имеется субъект Client. У него есть строковый идентификатор (id) и три параметра: surname, name
и patronymic. Вы рассказываете это системе в виде Java-класса:

```java
@Nf3Description("Это клиент")
public class Client {
  
  @Nf3Description("Это идентификатор клиента")
  @Nf3ID
  public String id;
  
  @Nf3Description("Это фамилия клиента")
  public String surname;
  
  @Nf3Description("Это имя клиента")
  public String name;
  
  @Nf3Description("Это отчество клиента")
  public String patronymic;
}
```

и система автоматически генерирует следующие таблицы:

```sql
-- Диалект PostgreSQL:

create table Client (
  id         varchar(32) primary key,
  surname    varchar(300),
  name       varchar(300),
  patronymic varchar(300)
);

create table m_client_surname (
  id      varchar(32) not null references Client,
  ts      timestamp not null default clock_timestamp(),
  surname varchar(300),
  author  varchar(32)
);

create table m_client_name (
  id     varchar(32) not null references Client,
  ts     timestamp not null default clock_timestamp(),
  name   varchar(300),
  author varchar(32)
);

create table m_client_patronymic (
  id         varchar(32) not null references Client,
  ts         timestamp not null default clock_timestamp(),
  patronymic varchar(300),
  author     varchar(32)
);
```

Также система автоматически генерирует некий Java-класс AutoGeneratedAccessClass (имя можно указать любое).
После этого вы можете написать что-то типа такого:

```java

class CoolClass {

  AutoGeneratedAccessClass accessDb;

  //здесь инициируется поле accessDb

  void someMethod() {

    accessDb.client("anyClientId")
      .surname("Пушкин")
      .name("Александр")
      .patronymic("Сергеевич")
      .commit();

  }

}

```

При вызове метода `commit` происходить запись новых значений указанных полей во все таблицы:
`Client`, `m_client_surname`, `m_client_name`, `m_client_patronymic`.
При этом поле `author` заполняется значением из сессии.

Сессию удобнее всего разместить в переменной ThreadLocal.

